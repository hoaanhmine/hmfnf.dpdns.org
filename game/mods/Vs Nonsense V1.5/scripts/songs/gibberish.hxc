import funkin.play.song.Song;
import flixel.FlxSprite;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.play.PlayStatePlaylist;
import funkin.play.PlayState;
import funkin.graphics.FunkinSprite;
import funkin.play.cutscene.CutsceneType;
import flixel.FlxG;
import funkin.save.Save;
import funkin.play.Countdown;
import funkin.audio.FunkinSound;
import flixel.util.FlxTimer;
import flixel.tweens.FlxTween;
import funkin.Conductor;
import funkin.play.cutscene.VideoCutscene;

class GibberishSong extends Song {

  var nonsenseModule:Module;
  var canEnding:Bool = false;

  var hasFailedPrevSong:Bool = false;

  var started:Bool = false;

  var bgFrontSprite:FunkinSprite;
  var playedEnding:Bool = false;
  var hasMissed:Bool = false;

  var playedIntroCutscene:Bool = false;

  var pointCamPosition:Array<Float> = [0, 0];

  function new() {
    super('gibberish');
  }

  function onCreate(event:ScriptEvent):Void
  {
    super.onCreate(event);

    if (!PlayStatePlaylist.isStoryMode) return;

    nonsenseModule = ModuleHandler.getModule('nonsense-module');

    hasFailedPrevSong = nonsenseModule.scriptCall('getFailedSongs').indexOf("Contextual") != -1;

    hasMissed = false;
    playedEnding = false;
    canEnding = false;

    playedIntroCutscene = false;
  }

  function makeBlackBG():Void {
    bgFrontSprite = new FunkinSprite(0, 0);
    bgFrontSprite.makeSolidColor(2000, 2500, 0xFF000000);
    bgFrontSprite.cameras = [PlayState.instance.camCutscene]; // Show over the HUD but below the video.
    // this
    bgFrontSprite.visible = false;
    bgFrontSprite.zIndex = -10000;
    PlayState.instance.add(bgFrontSprite);
    PlayState.instance.refresh();
  }

  public override function onCountdownStart(event:CountdownScriptEvent):Void {
		super.onCountdownStart(event);

    if (!PlayStatePlaylist.isStoryMode){
      playedIntroCutscene = true;
    }

    trace(playedIntroCutscene);

    if (!playedIntroCutscene) {
      trace('Pausing countdown to play a video cutscene (`darnell`)');

      playedIntroCutscene = true;

      event.cancel(); // CANCEL THE COUNTDOWN!

      VideoCutscene.play(Paths.videos(this.id + (hasFailedPrevSong ? '-bad' : '-good')));
      //PlayState.instance.startCountdown();
    }
  }

  public override function onCountdownStep(event:CountdownScriptEvent):Void {
    if (!started){
      event.cancel();
      Conductor.instance.update(0);
      started = true;
    }
  }

  function onBeatHit(event:SongTimeScriptEvent):Void {
    if (!PlayStatePlaylist.isStoryMode) return;

    switch (event.beat) {
      case 4:
        PlayState.instance.health = 0.05;
      case 88:
        canEnding = true;
    }
  }

  public function listDifficulties(variationId:String, variationIds:Array<String>, showLocked:Bool):Array<String> {
		/*if (showLocked || Save.instance.hasBeatenSong(this.id)) {
			return super.listDifficulties(variationId, variationIds);
		}*/

		// Hide all difficulties if the player has not beaten the week.
		return [];
	}

  function onSongRetry(event:SongRetryScriptEvent):Void {
    FlxG.camera.shake(0, 0);

    if (!PlayStatePlaylist.isStoryMode) return;
    canEnding = false;
  }

  function onNoteMiss(event:NoteScriptEvent):Void {
    loseEnding();
  }

  function onNoteGhostMiss(event:GhostMissNoteScriptEvent):Void {
    loseEnding();
  }

  function onSongEnd(event:ScriptEvent):Void {
    if (!PlayStatePlaylist.isStoryMode || playedEnding){
      hasMissed = false;
      playedEnding = false;
      return;
    }

    event.cancel();

    nonsenseModule.scriptCall('clearFailedSongs');

    if (hasMissed) {
      loseCutscene();
    }else{
      makeBlackBG();
      bgFrontSprite.visible = true;
      
      new FlxTimer().start(0.00001, _ -> {
        FlxG.camera.shake(0);
      });
      
      loadVideoCutscene();
    }
  }

  function loadVideoCutscene():Void {
    if (!PlayStatePlaylist.isStoryMode) return null;
    playedEnding = true;
    VideoCutscene.play(Paths.videos('credits-' + (hasMissed ? 'bad' : 'good')), CutsceneType.ENDING);
  }

  function loseEnding():Void{
    if (!canEnding || !PlayStatePlaylist.isStoryMode) return;
    hasMissed = true;
    
    pointCamPosition = [PlayState.instance.cameraFollowPoint.x, PlayState.instance.cameraFollowPoint.x];

    Conductor.instance.update(99999);
  }

  function loseCutscene():Void {
    if (!PlayStatePlaylist.isStoryMode) return;

    makeBlackBG();

    new FlxTimer().start(0.00001, _ -> { //skipping the song activates all the events in the chart so I have to set a timer to wait for the next frame
      FlxG.camera.shake(0);

      var bfPoint = PlayState.instance.currentStage.getBoyfriend().cameraFocusPoint;

      PlayState.instance.tweenCameraZoom(1, 0);

      PlayState.instance.resetCamera(false, false, false);
      PlayState.instance.cancelCameraFollowTween();
      PlayState.instance.cameraFollowPoint.setPosition(bfPoint.x + 180, bfPoint.y);
    });

    PlayState.instance.camHUD.visible = false;

    var bgBlueBalled:FunkinSprite = new FunkinSprite(-300, -200);
    bgBlueBalled.makeSolidColor(2000, 2500, 0xFF000000);
    // this
    bgBlueBalled.scrollFactor.set(0, 0);
    bgBlueBalled.zIndex = 500;
    //bgBlueBalled.visible = false;
    PlayState.instance.add(bgBlueBalled);

    var bfBalls:FlxSprite = FunkinSprite.createSparrow(1050, 400, 'characters/BoyFriend_Death_Hand');
    bfBalls.animation.addByPrefix("idle", "Hand BF dies0", 24, false);
    //bfBalls.visible = false;
    bfBalls.animation.play("idle");
    bfBalls.zIndex = 500;
    PlayState.instance.add(bfBalls);

    FunkinSound.playOnce(Paths.sound('gameplay/gameover/fnf_loss_sfx'));

    new FlxTimer().start(26 / 24, _ -> {
      bgFrontSprite.visible = true;
      new FlxTimer().start(26 / 24, _ -> {
        loadVideoCutscene();
      });
    });
  }
}